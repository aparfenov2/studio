// This Source Code Form is subject to the terms of the Mozilla Public
// License, v2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/

import * as IDB from "idb/with-async-ittr";

import Log from "@foxglove/log";
import { StoredExtension, IExtensionStorage, ExtensionInfo } from "@foxglove/studio-base";

const log = Log.getLogger(__filename);

const DATABASE_NAME = "foxglove-extensions";
const METADATA_STORE_NAME = "metadata";
const EXTENSION_STORE_NAME = "extensions";

interface ExtensionsDB extends IDB.DBSchema {
  metadata: {
    key: string;
    value: {
      metadata: ExtensionInfo;
    };
  };
  extensions: {
    key: string;
    value: {
      extension: StoredExtension;
    };
  };
}

export class IdbExtensionStorage implements IExtensionStorage {
  #db = IDB.openDB<ExtensionsDB>(DATABASE_NAME, 1, {
    upgrade: (db) => {
      log.debug("Creating extension metadata db", { storeName: METADATA_STORE_NAME });

      db.createObjectStore(METADATA_STORE_NAME, {
        keyPath: "metadata.id",
      });

      db.createObjectStore(EXTENSION_STORE_NAME, {
        keyPath: "extension.id",
      });
    },
  });

  async list(): Promise<ExtensionInfo[]> {
    const records = await (await this.#db).getAll(METADATA_STORE_NAME);

    log.debug("Listing extensions", { records });

    return records.map((record) => record.metadata);
  }

  async get(id: string): Promise<undefined | StoredExtension> {
    const record = await (await this.#db).get(EXTENSION_STORE_NAME, id);
    log.debug("Getting extension", { id, record });
    return record?.extension;
  }

  async put(extension: StoredExtension): Promise<StoredExtension> {
    log.debug("Storing extension", { extension });

    const transaction = (await this.#db).transaction(
      [METADATA_STORE_NAME, EXTENSION_STORE_NAME],
      "readwrite",
    );
    await Promise.all([
      transaction.db.put(METADATA_STORE_NAME, { metadata: extension.info }),
      transaction.db.put(EXTENSION_STORE_NAME, { extension }),
      transaction.done,
    ]);

    return extension;
  }

  async delete(id: string): Promise<void> {
    log.debug("Deleting extension", { id });

    const transaction = (await this.#db).transaction(
      [METADATA_STORE_NAME, EXTENSION_STORE_NAME],
      "readwrite",
    );
    await Promise.all([
      transaction.db.delete(METADATA_STORE_NAME, id),
      transaction.db.delete(EXTENSION_STORE_NAME, id),
      transaction.done,
    ]);
  }
}
