(()=>{var se={93986:(i,g,p)=>{"use strict";var _=p(80144),e=p.n(_);function w(t,n){const r=[];let o=0;for(const s of t){const c=n(s,o++);c&&r.push(c)}return r}const x=[e().factory.createModifier(e().SyntaxKind.ExportKeyword),e().factory.createModifier(e().SyntaxKind.DeclareKeyword)],b=(t,n)=>e().factory.createPropertySignature(void 0,t,void 0,n),D=t=>e().factory.createInterfaceDeclaration(x,t,void 0,void 0,[b("sec",e().factory.createKeywordTypeNode(e().SyntaxKind.NumberKeyword)),b("nsec",e().factory.createKeywordTypeNode(e().SyntaxKind.NumberKeyword))]),W=e().factory.createInterfaceDeclaration(x,"json",void 0,void 0,[]),j=t=>t.replace(/\//g,"__"),Ne=new Map([["uint8",e().SyntaxKind.NumberKeyword],["int8",e().SyntaxKind.NumberKeyword],["uint16",e().SyntaxKind.NumberKeyword],["int16",e().SyntaxKind.NumberKeyword],["uint32",e().SyntaxKind.NumberKeyword],["int32",e().SyntaxKind.NumberKeyword],["float32",e().SyntaxKind.NumberKeyword],["float64",e().SyntaxKind.NumberKeyword],["int64",e().SyntaxKind.NumberKeyword],["uint64",e().SyntaxKind.NumberKeyword],["string",e().SyntaxKind.StringKeyword],["bool",e().SyntaxKind.BooleanKeyword]]),_e=new Map([["uint8","Uint8Array"],["int8","Int8Array"]]),ae=D("Time"),H=D("Duration"),Ie=new Map([["time",ae],["duration",H]]),ce=t=>{const n={};for(const[r,o]of t){if(r.includes(".")||n[r])continue;const s=w(o.definitions,({name:c,type:u,isArray:f,isConstant:a})=>{let E;const N=_e.get(u),C=Ne.get(u),O=Ie.get(u);if(a!==!0)return f===!0&&N!=null?E=e().factory.createTypeReferenceNode(N):C!=null?E=e().factory.createKeywordTypeNode(C):O?E=e().factory.createTypeReferenceNode(O.name):E=e().factory.createTypeReferenceNode(j(u)),f===!0&&N==null&&(E=e().factory.createArrayTypeNode(E)),b(c,E)});n[r]=e().factory.createInterfaceDeclaration([e().factory.createModifier(e().SyntaxKind.ExportKeyword)],j(r),void 0,void 0,s)}return n},ve=({topics:t,datatypes:n})=>{let r=e().factory.createInterfaceDeclaration(x,"TopicsToMessageDefinition",void 0,void 0,[]);const o=e().factory.createInterfaceDeclaration(x,"Input",[e().factory.createTypeParameterDeclaration([],"T",e().factory.createTypeOperatorNode(e().SyntaxKind.KeyOfKeyword,e().factory.createTypeReferenceNode(r.name)))],void 0,[b("topic",e().factory.createTypeReferenceNode("T")),b("receiveTime",e().factory.createTypeReferenceNode("Time")),b("message",e().factory.createTypeReferenceNode("TopicsToMessageDefinition[T]"))]),s="Messages";let c=ce(n);t.forEach(({name:N,schemaName:C})=>{C!=null&&(c[C]||(c={...c,...ce(new Map(Object.entries({[C]:{definitions:[]}})))}),r=e().factory.updateInterfaceDeclaration(r,x,r.name,void 0,void 0,[...r.members,b(e().factory.createStringLiteral(N),e().factory.createTypeReferenceNode(`${s}.${j(C)}`))]))});const u=e().factory.createModuleDeclaration(x,e().factory.createIdentifier(s),e().factory.createModuleBlock(Object.values(c).map(N=>N)),e().NodeFlags.Namespace),f=e().createSourceFile("","",e().ScriptTarget.Latest,!1,e().ScriptKind.TS),a=e().createPrinter();return`
    ${a.printNode(e().EmitHint.Unspecified,W,f)}
    ${a.printNode(e().EmitHint.Unspecified,r,f)}
    ${a.printNode(e().EmitHint.Unspecified,H,f)}
    ${a.printNode(e().EmitHint.Unspecified,ae,f)}

    /**
     * This type contains every message declaration in your bag, so that you can
     * refer to the type "std_msgs/RGBA" as "std_msgs__RGBA" wherever you like.
     */
    ${a.printNode(e().EmitHint.Unspecified,u,f)}

    /**
     * To correctly type your inputs, you use this type to refer to specific
     * input topics, e.g. 'Input<"/your_input_topic">'. If you have
     * multiple input topics, use a union type, e.g.
     * 'Input<"/your_input_topic_1"> |
     * Input<"/your_input_topic_2">'.
     *
     * These types are dynamically generated from the bag(s) currently in your
     * Foxglove Studio session, so if a datatype changes, your User Script
     * may not compile on the newly formatted bag.
     */
    ${a.printNode(e().EmitHint.Unspecified,o,f)}
  `},y={Hint:1,Info:2,Warning:4,Error:8},m={Typescript:"Typescript",DatatypeExtraction:"DatatypeExtraction",InputTopicsChecker:"InputTopicsChecker",OutputTopicChecker:"OutputTopicChecker",Runtime:"Runtime"},T={RUNTIME:1,DatatypeExtraction:{NO_DEFAULT_EXPORT:1,NON_FUNC_DEFAULT_EXPORT:2,NO_TYPE_RETURN:3,BAD_TYPE_RETURN:4,UNKNOWN_ERROR:5,NO_UNIONS:6,NO_FUNCTIONS:7,NO_CLASSES:8,NO_TYPE_LITERALS:9,NO_TUPLES:10,NO_INTERSECTION_TYPES:11,NO_TYPEOF:12,PREFER_ARRAY_LITERALS:13,STRICT_MARKERS_RETURN_TYPE:14,LIMITED_UNIONS:15,NO_NESTED_ANY:16,NO_MAPPED_TYPES:17,INVALID_PROPERTY:18,INVALID_INDEXED_ACCESS:19},InputTopicsChecker:{NO_TOPIC_AVAIL:1,NO_INPUTS_EXPORT:2,EMPTY_INPUTS_EXPORT:3,BAD_INPUTS_TYPE:4},OutputTopicChecker:{NO_OUTPUTS:1,NOT_UNIQUE:2,EXISTING_TOPIC:3}},ue={severity:y.Error,message:"No 'default export' function found.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_DEFAULT_EXPORT},pe={severity:y.Error,message:"The 'default export' must be assigned to a function.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NON_FUNC_DEFAULT_EXPORT},U={severity:y.Error,message:"The 'default export' function must return an object type with at least one property.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.BAD_TYPE_RETURN},Pe={severity:y.Error,message:"The 'default export' function can only return union types of the form: 'YourType | undefined'.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.LIMITED_UNIONS},De={severity:y.Error,message:"Unions are not allowed in return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_UNIONS},de={severity:y.Error,message:"Functions are not allowed as or in the return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_FUNCTIONS},Oe={severity:y.Error,message:"Type literals are not allowed as or in the return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_TYPE_LITERALS},fe={severity:y.Error,message:"Type intersections are not allowed as or in the return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_INTERSECTION_TYPES},Re={severity:y.Error,message:"Please use array literal syntax (e.g. 'number[]') instead of the 'Array<number>'.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.PREFER_ARRAY_LITERALS},z={severity:y.Error,message:"Classes are not allowed as or in the return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_CLASSES},Ce={severity:y.Error,message:"'typeof' cannot be used as or in the return type",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_TYPEOF},Ke={severity:y.Error,message:"Tuples are not allowed as types.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_TUPLES},ke={severity:y.Error,message:"Cannot nest 'any' in the return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_NESTED_ANY},Me={severity:y.Error,message:"MappedTypes such as Record<Keys,Type> are not supported.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_MAPPED_TYPES},le=100;class h extends Error{diagnostic;constructor(n){super(),this.diagnostic=n}}const Le=(t,n)=>e().forEachChild(t,r=>{if(n.includes(r.kind))return r}),Y=(t,n)=>{for(const r of t.declarations??[])if(n.includes(r.kind))return r},Fe=(t,n,r)=>{const o=J(n);if(!o)return;const s=t.getDeclaredTypeOfSymbol(o);return Y(s.symbol??s.aliasSymbol,r)},ye=(t=[],n)=>{const r={};for(let o=0;o<t.length;o++){const s=t[o];s&&(r[s.name.escapedText.toString()]={current:s,parent:n[o]??{parent:void 0,current:s.default}})}return r},Ae=(t=[],n)=>{const r={};return t.forEach((o,s)=>{const c=o.getText(),u=n[c]??n[s],f=o;r[s]={current:f,parent:u}}),r},ge=t=>t.getSourceFile().fileName.endsWith("ros/index.d.ts");function J(t){return t?.symbol}const Ue=(t,n)=>{const r=J(t);if(!r)return;const o=n.getExportsOfModule(r).find(f=>f.escapedName==="default");if(!o)throw new h(ue);const s=Y(o,[e().SyntaxKind.FunctionDeclaration]);if(s)return s;const c=Y(o,[e().SyntaxKind.ExportAssignment]);if(!c)throw new h(ue);const u=Le(c,[e().SyntaxKind.FunctionDeclaration,e().SyntaxKind.FunctionExpression,e().SyntaxKind.ArrowFunction,e().SyntaxKind.Identifier]);if(!u)throw new h(pe);return u},Ye=(t,n)=>{const o=t.getTypeAtLocation(n).getCallSignatures(),s=o[0];if(o.length!==1||!s)throw new h(pe);const u=t.getReturnTypeOfSignature(s).getNonNullableType();if(u.isIntersection())throw new h(fe);if(u.isClass())throw new h(z);if(u.isUnion())throw new h(Pe);const f=u.getSymbol();if(!f)throw new h(U);if(!f.declarations||f.declarations.length===0)throw new h(U);let a;if(f.declarations.length===1?a=f.declarations[0]:a=f.declarations.filter(E=>E.kind===e().SyntaxKind.InterfaceDeclaration)[0],!a)throw new h(U);if(e().isTypeLiteralNode(a))return a;if(e().isInterfaceDeclaration(a))return a;throw e().isMappedTypeNode(a)?new h(Me):e().isClassDeclaration(a)?new h(z):e().isFunctionLike(a)?new h(de):new h(U)},me=(t,n,r,o,s,c=1,u={})=>{if(c>le)throw new Error("Max AST traversal depth exceeded.");const f=e().isInterfaceDeclaration(n)?n.name.text:void 0,a=f!=null?o[f]:void 0;if(ge(n)&&a!=null)return{outputDatatype:a,datatypes:s};const E=n.getSourceFile().fileName;if(E==="/studio_script/generatedTypes.ts"&&e().isPropertySignature(n.parent)&&e().isStringLiteral(n.parent.name))return{outputDatatype:n.parent.name.text,datatypes:s};const N=/^\/studio_script\/node_modules\/@foxglove\/schemas\/(\w+)\.ts$/,O=E.match(N)?.[1];if(O)return{outputDatatype:`foxglove.${O}`,datatypes:s};let G=new Map;const M=(d,S,I=!1,R=!1,K={},L=1)=>{if(L>le)throw new Error("Max AST traversal depth exceeded.");switch(S.kind){case e().SyntaxKind.InterfaceDeclaration:case e().SyntaxKind.TypeLiteral:{const v=S,P=J(S)?.name,k=P!=null?o[P]:void 0,F=ge(v)&&k!=null?k:`${r}/${d}`,A=e().isInterfaceDeclaration(S)?ye(S.typeParameters,K):K,{datatypes:be}=me(t,v,F,o,s,c+1,A),te=be.get(F)?.definitions??[];if(te.length===2){const re=te.find(oe=>oe.name==="sec"),ne=te.find(oe=>oe.name==="nsec");if(re&&ne&&re.isComplex!==!0&&ne.isComplex!==!0&&re.isArray!==!0&&ne.isArray!==!0)return{name:d,type:"time",isArray:!1,isComplex:!1,arrayLength:void 0}}return G=new Map([...G,...be]),{name:d,type:F,isArray:I,isComplex:!0,arrayLength:void 0}}case e().SyntaxKind.ArrayType:return M(d,S.elementType,!0,!0,K,L+1);case e().SyntaxKind.BigIntKeyword:return{name:d,type:"int64",isArray:I,isComplex:R,arrayLength:void 0};case e().SyntaxKind.NumberKeyword:return{name:d,type:"float64",isArray:I,isComplex:R,arrayLength:void 0};case e().SyntaxKind.StringKeyword:return{name:d,type:"string",isArray:I,isComplex:R,arrayLength:void 0};case e().SyntaxKind.BooleanKeyword:return{name:d,type:"bool",isArray:I,isComplex:R,arrayLength:void 0};case e().SyntaxKind.TypeAliasDeclaration:{const v=S,P=ye(v.typeParameters,K);return M(d,v.type,I,R,P,L+1)}case e().SyntaxKind.TypeReference:{const v=S,P=t.getSymbolAtLocation(v.typeName);if(P?.escapedName==="Array")throw new h(Re);if(!P)throw new Error("Could not find symbol");const k=Y(P,[e().SyntaxKind.TypeParameter]);if(k){if(K[k.name.escapedText.toString()]){let A=K[k.name.escapedText.toString()];for(;A?.parent;)A=A.parent;return M(d,A.current,I,R,K,L+1)}throw new Error(`Could not find type ${k.getText()} in type map.`)}const F=Y(P,[e().SyntaxKind.TypeAliasDeclaration,e().SyntaxKind.InterfaceDeclaration,e().SyntaxKind.ImportSpecifier,e().SyntaxKind.ClassDeclaration,e().SyntaxKind.EnumDeclaration]);if(!F)throw new Error("Could not find next node");return M(d,F,I,R,Ae(v.typeArguments,K),L+1)}case e().SyntaxKind.TypeQuery:throw new h(Ce);case e().SyntaxKind.ImportSpecifier:{const v=Fe(t,S,[e().SyntaxKind.TypeLiteral,e().SyntaxKind.InterfaceDeclaration,e().SyntaxKind.TypeAliasDeclaration]);if(!v)throw new Error("Failed to find import declaration");return M(d,v,I,R,K,L+1)}case e().SyntaxKind.IntersectionType:throw new h(fe);case e().SyntaxKind.TupleType:throw new h(Ke);case e().SyntaxKind.StringLiteral:case e().SyntaxKind.NumericLiteral:case e().SyntaxKind.LiteralType:throw new h(Oe);case e().SyntaxKind.ClassDeclaration:throw new h(z);case e().SyntaxKind.EnumDeclaration:return{name:d,type:"uint32",isArray:I,isComplex:R,arrayLength:void 0};case e().SyntaxKind.UnionType:throw new h(De);case e().SyntaxKind.FunctionType:throw new h(de);case e().SyntaxKind.AnyKeyword:throw new h(ke);default:{const P=t.getTypeAtLocation(S).symbol;if(P==null)throw new h({severity:y.Error,message:`Unsupported type for member '${d}'.`,source:m.DatatypeExtraction,code:T.DatatypeExtraction.BAD_TYPE_RETURN});const k=P.declarations?.[0];if(P.declarations?.length!==1||!k)throw new h(U);return M(d,k,!1,void 0,K,L+1)}}},{members:q=[]}=n,ee=q.map(d=>{if(!d.name)throw new h({severity:y.Error,message:`Encountered type member with no name in ${f??r}`,source:m.DatatypeExtraction,code:T.DatatypeExtraction.INVALID_PROPERTY});if(!e().isPropertySignature(d))throw new h({severity:y.Error,message:`Unexpected type member (kind ${d.kind}) in ${f??r}`,source:m.DatatypeExtraction,code:T.DatatypeExtraction.INVALID_PROPERTY});if(!d.type)throw new h({severity:y.Error,message:`Member ${d.name.getText()} has no type in ${f??r}`,source:m.DatatypeExtraction,code:T.DatatypeExtraction.INVALID_PROPERTY});return M(d.name.getText(),d.type,!1,!1,u,c+1)});return{outputDatatype:r,datatypes:new Map([...G,...new Map([[r,{definitions:ee}]])])}};var $e=p(64942);const Be=t=>{switch(t){case e().DiagnosticCategory.Error:return y.Error;case e().DiagnosticCategory.Warning:return y.Warning;case e().DiagnosticCategory.Message:return y.Info;case e().DiagnosticCategory.Suggestion:return y.Hint;default:throw new Error("Diagnostic category not recognized")}},We=t=>{if(!t.file||t.start==null||t.length==null)throw new Error("Invariant: diagnostic is not initialized");const{line:n,character:r}=t.file.getLineAndCharacterOfPosition(t.start),{line:o,character:s}=t.file.getLineAndCharacterOfPosition(t.start+t.length);return{message:Te(t.messageText,`
`),severity:Be(t.category),source:"Typescript",startLineNumber:n,startColumn:r,endLineNumber:o,endColumn:s,code:t.code}};function Te(t,n,r=0){if(typeof t=="string")return t;if(t==null)return"";let o="";if(r>0){o+=n;for(let s=0;s<r;s++)o+="  "}if(o+=t.messageText,t.next)for(const s of t.next)o+=Te(s,n,r+1);return o}const he={strict:!0,target:e().ScriptTarget.ES2022,module:e().ModuleKind.CommonJS};var je=p(11701);const He=`type MessageTypeByTopic = {
  // placeholder
};
type MessageTypeBySchemaName = {
  // placeholder
};

export type { MessageTypeByTopic, MessageTypeBySchemaName };
`,Ee=t=>t.diagnostics.some(({severity:n})=>n===y.Error),Ve=t=>{const{sourceFile:n,typeChecker:r}=t;if(!n||!r){const a={severity:y.Error,message:"Either the 'sourceFile' or 'typeChecker' is absent. There is a problem with the `compile` step.",source:m.InputTopicsChecker,code:T.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,a]}}const o=r.getSymbolAtLocation(n);if(!o){const a={severity:y.Error,message:"Must export an input topics array. E.g. 'export const inputs = ['/some_topics']'",source:m.InputTopicsChecker,code:T.InputTopicsChecker.NO_INPUTS_EXPORT};return{...t,diagnostics:[...t.diagnostics,a]}}const s=r.getExportsOfModule(o).find(a=>a.escapedName==="inputs");if(!s){const a={severity:y.Error,message:"Must export a non-empty inputs array.",source:m.InputTopicsChecker,code:T.InputTopicsChecker.EMPTY_INPUTS_EXPORT};return{...t,diagnostics:[...t.diagnostics,a]}}const c=s.declarations?.[0];if(!c||!e().isVariableDeclaration(c)){const a={severity:y.Error,message:"inputs export must be an array variable.",source:m.InputTopicsChecker,code:T.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,a]}}if(!c.initializer||!e().isArrayLiteralExpression(c.initializer)){const a={severity:y.Error,message:"inputs export must be an array variable.",source:m.InputTopicsChecker,code:T.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,a]}}const u=c.initializer.elements;if(u.some(({kind:a})=>a!==e().SyntaxKind.StringLiteral)){const a={severity:y.Error,message:"The exported 'inputs' variable must be an array of string literals. E.g. 'export const inputs = ['/some_topics']'",source:m.InputTopicsChecker,code:T.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,a]}}const f=w(u,a=>{if(e().isStringLiteral(a))return a.text});if(f.length===0){const a={severity:y.Error,message:'Must include non-empty inputs array, e.g. export const inputs = ["/some_input_topic"];',source:m.InputTopicsChecker,code:T.InputTopicsChecker.EMPTY_INPUTS_EXPORT};return{...t,diagnostics:[...t.diagnostics,a]}}return{...t,inputTopics:f}},Xe=t=>{const n=/^\s*export\s+const\s+output\s*=\s*("([^"]+)"|'([^']+)')/gm.exec(t.sourceCode),r=n?.[2]??n?.[3];if(r==null){const o={severity:y.Error,message:`Must include an output, e.g. export const output = "${je.wd}your_output_topic";`,source:m.OutputTopicChecker,code:T.OutputTopicChecker.NO_OUTPUTS};return{...t,diagnostics:[...t.diagnostics,o]}}return{...t,outputTopic:r}},Ge=(t,n)=>{const{inputTopics:r}=t,o=n.map(({name:c})=>c),s=[];for(const c of r)o.includes(c)||s.push({severity:y.Error,message:`Input "${c}" is not yet available`,source:m.InputTopicsChecker,code:T.InputTopicsChecker.NO_TOPIC_AVAIL});return{...t,diagnostics:[...t.diagnostics,...s]}},ze=t=>{const{sourceCode:n,rosLib:r,typesLib:o}=t,s=he,c="/studio_script/index.ts",u=(0,$e.L)(),f=new Map,a=new Map;a.set(c,n),a.set(u.rosLib.filePath,r),a.set("/studio_script/generatedTypes.ts",o||He),u.utilityFiles.forEach(d=>a.set(d.filePath,d.sourceCode)),u.declarations.forEach(d=>a.set(d.filePath,d.sourceCode));let E="",N=!1;const C={getDefaultLibFileName:()=>u.defaultLibFileName,getCurrentDirectory:()=>"",getCanonicalFileName:d=>d,useCaseSensitiveFileNames:()=>!1,readFile:()=>{},fileExists:d=>{for(const[S]of a.entries())if(d===S||d.endsWith(S))return!0;return!1},writeFile:(d,S)=>{N=!0,d==="/studio_script/index.js"?E=S:f.set(d,S)},getNewLine:()=>`
`,getSourceFile:d=>{let S="";for(const[I,R]of a.entries())if(d===I||d.endsWith(I)){S=R;break}return e().createSourceFile(d,S,he.target,!0)}},O=e().createProgram([c],s,C);if(O.emit(),!N){const d={severity:y.Error,message:"Program code was not emitted.",source:m.InputTopicsChecker,code:T.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,d]}}const M=[...O.getSemanticDiagnostics(),...O.getSyntacticDiagnostics()].map(We),q=O.getSourceFile(c),ee=O.getTypeChecker();return{...t,sourceFile:q,typeChecker:ee,transpiledCode:E,projectCode:f,diagnostics:[...t.diagnostics,...M]}},Je=t=>{if(Ee(t))return t;const{sourceFile:n}=t;if(!n)throw new Error("'sourceFile' is absent'. There is a problem with the `compile` step.");const r=n.forEachChild(s=>{if(e().isTypeAliasDeclaration(s)&&e().isTypeLiteralNode(s.type)&&s.name.text==="GlobalVariables")return s.type.members;if(e().isInterfaceDeclaration(s)&&s.name.text==="GlobalVariables")return s.members}),o=w(r??[],s=>{if(s.name&&(e().isIdentifier(s.name)||e().isStringLiteral(s.name)))return s.name.text});return{...t,globalVariables:o}},Qe=t=>{if(Ee(t))return t;const{sourceFile:n,typeChecker:r,name:o,datatypes:s}=t;if(!n||!r)throw new Error("Either the 'sourceFile' or 'typeChecker' is absent'. There is a problem with the `compile` step.");const c={};for(const u of s.keys())c[j(u)]=u;try{const u=Ue(n,r);if(!u)throw new Error("Your node must default export a function");const f=Ye(r,u),{outputDatatype:a,datatypes:E}=me(r,f,o,c,s);return{...t,datatypes:E,outputDatatype:a}}catch(u){return u instanceof h?{...t,diagnostics:[...t.diagnostics,u.diagnostic]}:{...t,diagnostics:[...t.diagnostics,{message:u.message,severity:y.Error,source:m.DatatypeExtraction,code:T.DatatypeExtraction.UNKNOWN_ERROR}]}}},Ze=(...t)=>(n,r)=>{let o=n;for(const s of t)o=s(o,r);return o},qe=t=>{const{name:n,sourceCode:r,topics:o,rosLib:s,typesLib:c,datatypes:u}=t;return{...Ze(Xe,ze,Ve,Ge,Qe,Je)({name:n,sourceCode:r,rosLib:s,typesLib:c,transpiledCode:"",projectCode:void 0,inputTopics:[],outputTopic:"",outputDatatype:"",diagnostics:[],globalVariables:[],datatypes:u,sourceFile:void 0,typeChecker:void 0},o),sourceFile:void 0,typeChecker:void 0}};var Q;const $="$$RESPONSE",Z="$$ERROR";function dt(){const t={onmessage:void 0,postMessage(r,o){const s=new MessageEvent("message",{data:r});n.onmessage&&n.onmessage(s)},terminate:()=>{}},n={onmessage:void 0,postMessage(r,o){const s=new MessageEvent("message",{data:r});t.onmessage&&t.onmessage(s)},terminate:()=>{}};return{local:t,remote:n}}class we{static transferables="$$TRANSFERABLES";#e;#n=0;#t={};#r=new Map;constructor(n){if(this.#e=n,this.#e.onmessage)throw new Error("channel.onmessage is already set. Can only use one Rpc instance per channel.");this.#e.onmessage=this.#o}#o=n=>{const{id:r,topic:o,data:s}=n.data;if(o===$){this.#t[r]?.(n.data),delete this.#t[r];return}new Promise(c=>{const u=this.#r.get(o);if(!u)throw new Error(`no receiver registered for ${o}`);c(u(s))}).then(c=>{if(!c){this.#e.postMessage({topic:$,id:r});return}const u=c[Q.transferables];delete c[Q.transferables];const f={topic:$,id:r,data:c};this.#e.postMessage(f,u)}).catch(c=>{const u={topic:$,id:r,data:{[Z]:!0,name:c.name,message:c.message,stack:c.stack}};this.#e.postMessage(u)})};terminate(){for(const[n,r]of Object.entries(this.#t))r({topic:$,id:n,data:{[Z]:!0,name:"Error",message:"Rpc terminated",stack:new Error().stack}})}async send(n,r,o){const s=this.#n++,c={topic:n,id:s,data:r},u=new Promise((f,a)=>{this.#t[s]=E=>{if(E.data?.[Z]!=null){const N=new Error(E.data.message);N.name=E.data.name,N.stack=E.data.stack,a(N)}else f(E.data)}});return this.#e.postMessage(c,o),await u}receive(n,r){if(this.#r.has(n))throw new Error(`Receiver already registered for topic: ${n}`);this.#r.set(n,r)}}Q=we;const et=we,Se=p.g;function tt(t){Se.foxgloveStudioReportErrorFn?.(t)}function ft(t){Se.foxgloveStudioReportErrorFn=t}class rt extends Error{details;extraInfo;message;constructor(n,r){if(super(),this.details=n,this.extraInfo=r,this.name="AppError",this.message="",n instanceof Error?this.message=n.stack??n.message:typeof n=="string"&&(this.message=n),r!=null)if(r.componentStack!=null)this.message+=`

${r.componentStack}`;else try{const o=JSON.stringify(r);this.message+=`

${o}`}catch{this.message+=`

[ Either cyclic object or object with BigInt(s) ]`}this.message===""&&(this.message="Unknown Error")}}const nt=()=>typeof p.g.postMessage<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,ot=()=>typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope,st=t=>{const n=typeof fetch<"u"&&fetch("data:test").then(()=>!0).catch(()=>!1);return async(...r)=>{if(await n)throw new Error("Content security policy too loose.");return t(...r)}},V=(t,n,r,o)=>{if(nt()){(o==="error"?console.error:o==="warn"?console.warn:console.info)("Web Worker has uninitialized sendNotification function; this means this error message cannot show up in the UI (so we show it here in the console instead).",t,n,r);return}console.error("Notification before error display is mounted",t,n,r)};let B=V;function it(t){if(B!==V)throw new Error("Tried to overwrite existing NotificationHandler");B=t}function lt(){if(B===V)throw new Error("Tried to unset NotificationHandler but it was already the default");B=V}function at(t,n,r,o){r==="app"&&(o==="warn"||o==="error")&&tt(new rt(n,t)),B(t,n,r,o)}at.expectCalledDuringTest=()=>{throw new Error("Should be overriden in setupTestFramework.ts")};function xe(t){it((n,r,o,s)=>{r instanceof Error||typeof r=="string"||console.warn("Invalid Error type",r),t.send("sendNotification",{message:n,details:r instanceof Error?r.toString():r,type:o,severity:s})})}function yt(t){xe(t),overwriteFetch()}let X=[];if(p.g.onerror=t=>{X.push(t.error.toString())},p.g.onunhandledrejection=t=>{X.push(String(t.reason instanceof Error?t.reason.message:t.reason))},!ot())throw new Error("Not in a SharedWorker.");p.g.onconnect=t=>{const n=t.ports[0];if(!n)throw new Error("NodeTransformWorker connect requires at least 1 message port.");const r=new et(n);X.forEach(async o=>{await r.send("error",o)}),X=[],p.g.onerror=o=>{r.send("error",o.error.toString())},p.g.onunhandledrejection=o=>{r.send("error",String(o.reason instanceof Error?o.reason.message:o.reason))},xe(r),r.receive("close",()=>{p.g.close()}),r.receive("transform",st(qe)),r.receive("generateRosLib",ve),n.start()}},23621:(i,g,p)=>{"use strict";p.d(g,{Y:()=>_,k:()=>e});const _="ros/index.d.ts",e=`
  export declare interface Duration {
    sec: number;
    nsec: number;
  }

  export declare interface Time {
    sec: number;
    nsec: number;
  }

  // Once a data source Messages will be populated with interfaces matching the data source messages.
  export declare namespace Messages {}

  // Once a data source TopicsToMessageDefinition will be populated with topic names to message interfaces.
  export declare interface TopicsToMessageDefinition {}

  /**
   * To correctly type your inputs, you use this type to refer to specific
   * input topics, e.g. 'Input<"/your_input_topic">'. If you have
   * multiple input topics, use a union type, e.g.
   * 'Input<"/your_input_topic_1"> |
   * Input<"/your_input_topic_2">'.
   *
   * These types are dynamically generated from the bag(s) currently in your
   * Foxglove Studio session, so if a datatype changes, your User Script
   * may not compile on the newly formatted bag.
   */
  export declare interface Input<T extends keyof TopicsToMessageDefinition> {
    topic: T;
    receiveTime: Time;
    message: TopicsToMessageDefinition[T];
  }

`},11701:(i,g,p)=>{"use strict";p.d(g,{wd:()=>_});const _="/studio_script/";function e(){const{palette:{mode:x,text:b}}=useTheme();return{dark:{base00:"transparent",base0B:"#ffa657",base09:"#7ee787",base07:"#79c0ff",base08:"#ff7b72",base0D:"#79c0ff",base03:b.secondary},light:{base00:"transparent",base0B:"#953800",base09:"#116329",base07:"#0550ae",base08:"#cf222e",base0D:"#0550ae",base03:b.secondary}}[x]}const w="Tab"},63136:(i,g,p)=>{"use strict";p.d(g,{Z:()=>e});const e={nextTick:(w,...x)=>{queueMicrotask(()=>{w(...x)})},title:"browser",browser:!0,env:{},argv:[]}},89424:()=>{},9445:()=>{},70546:()=>{},15490:()=>{},80136:()=>{},91389:()=>{},9865:()=>{},73860:()=>{},98752:()=>{}},ie={};function l(i){var g=ie[i];if(g!==void 0)return g.exports;var p=ie[i]={id:i,loaded:!1,exports:{}};return se[i].call(p.exports,p,p.exports,l),p.loaded=!0,p.exports}l.m=se,l.x=()=>{var i=l.O(void 0,[6635,7472,144,9308,1847,4942],()=>l(93986));return i=l.O(i),i},(()=>{var i=[];l.O=(g,p,_,e)=>{if(p){e=e||0;for(var w=i.length;w>0&&i[w-1][2]>e;w--)i[w]=i[w-1];i[w]=[p,_,e];return}for(var x=1/0,w=0;w<i.length;w++){for(var[p,_,e]=i[w],b=!0,D=0;D<p.length;D++)(e&!1||x>=e)&&Object.keys(l.O).every(H=>l.O[H](p[D]))?p.splice(D--,1):(b=!1,e<x&&(x=e));if(b){i.splice(w--,1);var W=_();W!==void 0&&(g=W)}}return g}})(),l.n=i=>{var g=i&&i.__esModule?()=>i.default:()=>i;return l.d(g,{a:g}),g},l.d=(i,g)=>{for(var p in g)l.o(g,p)&&!l.o(i,p)&&Object.defineProperty(i,p,{enumerable:!0,get:g[p]})},l.f={},l.e=i=>Promise.all(Object.keys(l.f).reduce((g,p)=>(l.f[p](i,g),g),[])),l.u=i=>""+i+"."+{144:"225c949245a52a3277be",1847:"8a82db6e66ac600d4515",4942:"9e66c115cc0603627f6e",6635:"3176a27e01453488dad0",7472:"273f69571dee607e9608",9308:"ad8e52b057e0345f177d"}[i]+".js",l.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),l.o=(i,g)=>Object.prototype.hasOwnProperty.call(i,g),l.r=i=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})},l.nmd=i=>(i.paths=[],i.children||(i.children=[]),i),(()=>{var i;l.g.importScripts&&(i=l.g.location+"");var g=l.g.document;if(!i&&g&&(g.currentScript&&(i=g.currentScript.src),!i)){var p=g.getElementsByTagName("script");if(p.length)for(var _=p.length-1;_>-1&&!i;)i=p[_--].src}if(!i)throw new Error("Automatic publicPath is not supported in this browser");i=i.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),l.p=i})(),(()=>{var i={1302:1},g=e=>{var[w,x,b]=e;for(var D in x)l.o(x,D)&&(l.m[D]=x[D]);for(b&&b(l);w.length;)i[w.pop()]=1;_(e)};l.f.i=(e,w)=>{i[e]||importScripts(l.p+l.u(e))};var p=self.webpackChunk=self.webpackChunk||[],_=p.push.bind(p);p.push=g})(),(()=>{var i=l.x;l.x=()=>Promise.all([6635,7472,144,9308,1847,4942].map(l.e,l)).then(i)})();var ct=l.x()})();

//# sourceMappingURL=1302.3424a41889d196e25efe.js.map