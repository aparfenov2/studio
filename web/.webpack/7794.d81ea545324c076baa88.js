"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7794],{17794:(Ee,Ie,u)=>{var x=u(90758),A=u(41253),C=u(25811),R=u(23503),O=u(87026);function X(s,e){const n=new Map;function t(o,c,p){let a=i=>i;const l=[];if(o.type!=="object")throw new Error(`Expected "type": "object" for schema ${c}, got ${JSON.stringify(o.type)}`);for(const[i,m]of Object.entries(o.properties)){if(Array.isArray(m.oneOf))if(m.oneOf.every(h=>typeof h.const=="number")){for(const h of m.oneOf)l.push({name:h.title,type:"uint32",isConstant:!0,value:h.const});l.push({name:i,type:"uint32"});continue}else throw new Error(`Unsupported type for ${p.concat(i).join(".")}: oneOf alternatives must have number values`);switch(m.type){case"boolean":l.push({name:i,type:"bool"});break;case"string":switch(m.contentEncoding){case void 0:l.push({name:i,type:"string"});break;case"base64":{l.push({name:i,type:"uint8",isArray:!0});const h=a;a=w=>{const g=w[i];if(typeof g=="string"){const b=new Uint8Array(O.length(g));if(O.decode(g,b,0)!==b.byteLength)throw new Error(`Failed to decode base64 data for ${p.concat(i).join(".")}`);w[i]=b}return h(w)};break}default:throw new Error(`Unsupported contentEncoding ${JSON.stringify(m.contentEncoding)} in ${p.concat(i).join(".")}`)}break;case"number":case"integer":l.push({name:i,type:"float64"});break;case"object":{const h=`${c}.${i}`,w=t(m,h,p.concat(i)),g=a;a=b=>{const E=b[i];return E!=null&&typeof E=="object"&&(b[i]=w(E)),g(b)},l.push({name:i,type:h,isComplex:!0});break}case"array":{const h=m.items;switch(h.type){case"boolean":l.push({name:i,type:"bool",isArray:!0});break;case"string":if(h.contentEncoding!=null)throw new Error(`Unsupported contentEncoding ${JSON.stringify(h.contentEncoding)} for array item ${p.concat(i).join(".")}`);l.push({name:i,type:"string",isArray:!0});break;case"number":case"integer":l.push({name:i,type:"float64",isArray:!0});break;case"object":{const w=`${c}.${i}`,g=t(m.items,w,p.concat(i)),b=a;a=E=>{const S=E[i];return Array.isArray(S)&&(E[i]=S.map(g)),b(E)},l.push({name:i,type:w,isComplex:!0,isArray:!0});break}default:throw new Error(`Unsupported type ${JSON.stringify(h.type)} for array item ${p.concat(i).join(".")}`)}break}case"null":default:throw new Error(`Unsupported type ${JSON.stringify(m.type)} for ${p.concat(i).join(".")}`)}}return n.set(c,{definitions:l}),a}const r=t(s,e,[]);return{datatypes:n,postprocessValue:r}}var K=u(11168),N=u.n(K);function Y(s){switch(s){case"double":return"float64";case"float":return"float32";case"int32":case"sint32":case"sfixed32":return"int32";case"uint32":case"fixed32":return"uint32";case"int64":case"sint64":case"sfixed64":return"int64";case"uint64":case"fixed64":return"uint64";case"bool":return"bool";case"string":return"string"}throw new Error(`Expected protobuf scalar type, got ${s}`)}function z(s){return s.replace(/^\./,"")}function U(s,e){const n=[];s.set(z(e.fullName),{definitions:n});for(const t of e.fieldsArray)if(t.resolvedType instanceof N().Enum){for(const[r,o]of Object.entries(t.resolvedType.values))n.push({name:r,type:"int32",isConstant:!0,value:o});n.push({type:"int32",name:t.name})}else if(t.resolvedType){const r=z(t.resolvedType.fullName);n.push({type:r,name:t.name,isComplex:!0,isArray:t.repeated}),s.has(r)||U(s,t.resolvedType)}else if(t.type==="bytes"){if(t.repeated)throw new Error("Repeated bytes are not currently supported");n.push({type:"uint8",name:t.name,isArray:!0})}else n.push({type:Y(t.type),name:t.name,isArray:t.repeated})}var Q=u(68217),q=u(25490),_=u(10955),D=u(17417),ee=u(92897),se=u(62098),L=u(15356),d=u(98357);function F(s){switch(s){case d.rB.Bool:return"bool";case d.rB.Byte:return"int8";case d.rB.UType:case d.rB.UByte:return"uint8";case d.rB.Short:return"int16";case d.rB.UShort:return"uint16";case d.rB.Int:return"int32";case d.rB.UInt:return"uint32";case d.rB.Long:return"int64";case d.rB.ULong:return"uint64";case d.rB.Float:return"float32";case d.rB.Double:return"float64";case d.rB.String:return"string";case d.rB.Vector:case d.rB.Obj:case d.rB.Union:case d.rB.Array:throw new Error(`${s} is not a simple type.`);case d.rB.None:case d.rB.MaxBaseType:throw new Error("None is not a valid type.")}}function T(s){if(typeof s=="string")return s;throw new Error(`Expected string, found ${typeof s}`)}function te(s,e){const n=[];switch(e.type?.baseType){case d.rB.UType:case d.rB.Bool:case d.rB.Byte:case d.rB.UByte:case d.rB.Short:case d.rB.UShort:case d.rB.Int:case d.rB.UInt:case d.rB.Long:case d.rB.ULong:case d.rB.Float:case d.rB.Double:case d.rB.String:case d.rB.None:{const t=F(e.type.baseType);if(e.type.index!==-1){const r=s.enums[e.type.index]?.values;if(r==null)throw new Error(`Invalid schema, missing enum values for field type ${s.enums[e.type.index]?.name}`);for(const o of r)n.push({name:T(o.name),type:t,isConstant:!0,value:o.value})}n.push({name:T(e.name),type:t});break}case d.rB.Vector:switch(e.type.element){case d.rB.Vector:case d.rB.Union:case d.rB.Array:case d.rB.None:throw new Error("Vectors of vectors, unions, arrays, and None's are unsupported.");case d.rB.Obj:n.push({name:T(e.name),type:T(s.objects[e.type.index]?.name),isComplex:!0,isArray:!0});break;default:{const t=F(e.type.element);if(e.type.index!==-1){const r=s.enums[e.type.index]?.values;if(r==null)throw new Error("Invalid schema");for(const o of r)n.push({name:T(o.name),type:t,isConstant:!0,value:o.value})}n.push({name:T(e.name),type:t,isArray:!0});break}}break;case d.rB.Obj:n.push({name:T(e.name),type:T(s.objects[e.type.index]?.name),isComplex:!0});break;case d.rB.Union:case d.rB.Array:case d.rB.MaxBaseType:case void 0:throw new Error("Unions and Arrays are not supported in mcap-support currently.")}return n}function ne(s,e){const n=new Map,t=new L.cZ(e),r=d.V_.getRootAsSchema(t),o=r.unpack();let c=-1;for(let i=0;i<o.objects.length;++i){const m=o.objects[i];m?.name===s&&(c=i);let h=[];if(m?.fields!=null){for(const w of m.fields)h=h.concat(te(o,w));n.set(T(m.name),{definitions:h})}}if(c===-1&&o.rootTable?.name!==s)throw new Error(`Type "${s}" is not available in the schema for "${o.rootTable?.name}".`);const a=new d._b(r).toObjectLambda(c,!0);return{datatypes:n,deserialize:i=>{const m=new L.cZ(new Uint8Array(i.buffer,i.byteOffset,i.byteLength)),h=new d.iA(m,c,m.readInt32(m.position())+m.position(),!1);return a(h)}}}var re=u(70943);function ae(s,e){const n=re.FileDescriptorSet.decode(e),t=N().Root.fromDescriptor(n);t.resolveAll();const r=t.lookupType(s),o=a=>{if(!a||!(a instanceof N().Type))return;for(const m of a.fieldsArray)m.name==="seconds"?m.name="sec":m.name==="nanos"&&(m.name="nsec");a.setup();const l=a.toObject,i=(m,h)=>{const w=l.call(a,m,h),{sec:g,nsec:b}=w;if(typeof g!="bigint"||typeof b!="number")return w;if(g>BigInt(Number.MAX_SAFE_INTEGER))throw new Error(`Timestamps with seconds greater than 2^53-1 are not supported (found seconds=${g}, nanos=${b})`);return{sec:Number(g),nsec:b}};a.toObject=i};o(t.lookup(".google.protobuf.Timestamp")),o(t.lookup(".google.protobuf.Duration"));const c=a=>r.toObject(r.decode(new Uint8Array(a.buffer,a.byteOffset,a.byteLength)),{defaults:!0}),p=new Map;if(U(p,r),!p.has(s))throw new Error(`Protobuf schema does not contain an entry for '${s}'. The schema name should be fully-qualified, e.g. '${z(r.fullName)}'.`);return{deserialize:c,datatypes:p}}function oe(s,e){const n=r=>{if(r.aggregatedKind==="union"){const o=r.cases.map(p=>({...p.type,predicates:p.predicates}));r.defaultCase!=null&&o.push(r.defaultCase);const{name:c}=r;return{name:c,definitions:o}}return r},t=s.map(n);return j(t,e)}function j(s,e){const n=new Map;return s.forEach(({name:t,definitions:r},o)=>{e!=null&&o===0?n.set(e,{name:e,definitions:r}):t!=null&&n.set(t,{name:t,definitions:r})}),n}function k(s){if(s.messageEncoding==="json"){if(s.schema!=null&&s.schema.encoding!=="jsonschema")throw new Error(`Message encoding ${s.messageEncoding} with schema encoding '${s.schema.encoding}' is not supported (expected jsonschema or no schema)`);const e=new TextDecoder;let n=new Map,t=r=>JSON.parse(e.decode(r));if(s.schema!=null){const r=s.schema.data.length>0?JSON.parse(e.decode(s.schema.data)):void 0;if(r!=null){if(typeof r!="object")throw new Error(`Invalid schema, expected JSON object, got ${typeof r}`);const{datatypes:o,postprocessValue:c}=X(r,s.schema.name);n=o,t=p=>c(JSON.parse(e.decode(p)))}}return{deserialize:t,datatypes:n}}if(s.messageEncoding==="flatbuffer"){if(s.schema?.encoding!=="flatbuffer")throw new Error(`Message encoding ${s.messageEncoding} with ${s.schema==null?"no encoding":`schema encoding '${s.schema.encoding}'`} is not supported (expected flatbuffer)`);return ne(s.schema.name,s.schema.data)}if(s.messageEncoding==="protobuf"){if(s.schema?.encoding!=="protobuf")throw new Error(`Message encoding ${s.messageEncoding} with ${s.schema==null?"no encoding":`schema encoding '${s.schema.encoding}'`} is not supported (expected protobuf)`);return ae(s.schema.name,s.schema.data)}if(s.messageEncoding==="ros1"){if(s.schema?.encoding!=="ros1msg")throw new Error(`Message encoding ${s.messageEncoding} with ${s.schema==null?"no encoding":`schema encoding '${s.schema.encoding}'`} is not supported (expected ros1msg)`);const e=new TextDecoder().decode(s.schema.data),n=(0,D.parse)(e),t=new ee.MessageReader(n);return{datatypes:j(n,s.schema.name),deserialize:r=>t.readMessage(r)}}if(s.messageEncoding==="cdr"){if(s.schema?.encoding!=="ros2msg"&&s.schema?.encoding!=="ros2idl"&&s.schema?.encoding!=="omgidl")throw new Error(`Message encoding ${s.messageEncoding} with ${s.schema==null?"no encoding":`schema encoding '${s.schema.encoding}'`} is not supported (expected "ros2msg" or "ros2idl")`);const e=new TextDecoder().decode(s.schema.data);if(s.schema.encoding==="omgidl"){const n=(0,Q.parseIDL)(e),t=new q.MessageReader(s.schema.name,n);return{datatypes:oe(n),deserialize:o=>t.readMessage(o)}}else{const t=s.schema.encoding==="ros2idl"?(0,_.parseRos2idl)(e):(0,D.parse)(e,{ros2:!0}),r=new se.MessageReader(t);return{datatypes:j(t,s.schema.name),deserialize:o=>r.readMessage(o)}}}throw new Error(`Unsupported encoding ${s.messageEncoding}`)}let ie;async function J(){return await(ie??=ce())}async function ce(){const[s,e,n]=await Promise.all([Promise.all([u.e(7372),u.e(3349)]).then(u.t.bind(u,3349,23)).then(async t=>(await t.isLoaded,t.decompress)),Promise.all([u.e(7372),u.e(3400)]).then(u.t.bind(u,3400,23)).then(async t=>(await t.default.isLoaded,t.default)),Promise.all([u.e(2984),u.e(3463)]).then(u.bind(u,94789)).then(async t=>await t.default.init())]);return{lz4:(t,r)=>e(t,Number(r)),bz2:(t,r)=>n.decompress(t,Number(r),{small:!1}),zstd:(t,r)=>s(t,Number(r))}}class de{file;constructor(e){this.file=e}async size(){return BigInt(this.file.size)}async read(e,n){if(e+n>this.file.size)throw new Error(`Read of ${n} bytes at offset ${e} exceeds file size ${this.file.size}`);return new Uint8Array(await this.file.slice(Number(e),Number(e+n)).arrayBuffer())}}function pe(s,e){if(e.length===0)return{};const n={};for(const t of e)t in s&&(n[t]=s[t]);return n}var y=u(44668),fe="../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIndexedIterableSource.ts";const P=R.ZP.getLogger(fe);class V{#e;#s=new Map;#t;#n;constructor(e){this.#e=e}async initialize(){let e,n;for(const a of this.#e.chunkIndexes)(e==null||a.messageStartTime<e)&&(e=a.messageStartTime),(n==null||a.messageEndTime>n)&&(n=a.messageEndTime);const t=new Map,r=new Map,o=new Map,c=[],p=new Map;for(const a of this.#e.channelsById.values()){const l=this.#e.schemasById.get(a.schemaId);if(a.schemaId!==0&&l==null){c.push({severity:"error",message:`Missing schema info for schema id ${a.schemaId} (channel ${a.id}, topic ${a.topic})`});continue}let i;try{i=k({messageEncoding:a.messageEncoding,schema:l})}catch(g){c.push({severity:"error",message:`Error in topic ${a.topic} (channel ${a.id}): ${g.message}`,error:g});continue}this.#s.set(a.id,{channel:a,parsedChannel:i,schemaName:l?.name});let m=r.get(a.topic);if(!m){m={name:a.topic,schemaName:l?.name},r.set(a.topic,m);const g=this.#e.statistics?.channelMessageCounts.get(a.id);g!=null&&t.set(a.topic,{numMessages:Number(g)})}const h=a.metadata.get("callerid")??String(a.id);let w=p.get(a.topic);w||(w=new Set,p.set(a.topic,w)),w.add(h);for(const[g,b]of i.datatypes)o.set(g,b)}return this.#t=(0,y.fromNanoSec)(e??0n),this.#n=(0,y.fromNanoSec)(n??e??0n),{start:this.#t,end:this.#n,topics:[...r.values()],datatypes:o,profile:this.#e.header.profile,problems:c,publishersByTopic:p,topicStats:t}}async*messageIterator(e){const n=e.topics,t=e.start??this.#t,r=e.end??this.#n;if(n.size===0||!t||!r)return;const o=Array.from(n.keys());for await(const c of this.#e.readMessages({startTime:(0,y.toNanoSec)(t),endTime:(0,y.toNanoSec)(r),topics:o,validateCrcs:!1})){const p=this.#s.get(c.channelId);if(!p){yield{type:"problem",problem:{message:`Received message on channel ${c.channelId} without prior channel info`,severity:"error"}};continue}try{const a=p.parsedChannel.deserialize(c.data),l=e.topics.get(p.channel.topic),i=l?.fields!=null?pe(a,l.fields):a;yield{type:"message-event",msgEvent:{topic:p.channel.topic,receiveTime:(0,y.fromNanoSec)(c.logTime),publishTime:(0,y.fromNanoSec)(c.publishTime),message:i,sizeInBytes:l?.fields==null?c.data.byteLength:0,schemaName:p.schemaName??""}}}catch(a){yield{type:"problem",problem:{message:`Error decoding message on ${p.channel.topic}`,error:a,severity:"error"}}}}}async getBackfillMessages(e){const{topics:n,time:t}=e,r=[];for(const o of n.keys())for await(const c of this.#e.readMessages({endTime:(0,y.toNanoSec)(t),topics:[o],reverse:!0,validateCrcs:!1})){const p=this.#s.get(c.channelId);if(!p){P.error(`Missing channel info for channel: ${c.channelId} on topic: ${o}`);continue}try{r.push({topic:p.channel.topic,receiveTime:(0,y.fromNanoSec)(c.logTime),publishTime:(0,y.fromNanoSec)(c.publishTime),message:p.parsedChannel.deserialize(c.data),sizeInBytes:c.data.byteLength,schemaName:p.schemaName??""})}catch(a){P.error(a)}break}return r.sort((o,c)=>(0,y.compare)(o.receiveTime,c.receiveTime)),r}}var Z=u(76635);const me=365*24*60*60;class H{#e;#s;#t;#n;constructor(e){this.#e=e}async initialize(){if(this.#e.size>1024*1024*1024)throw new Error("Unable to open unindexed MCAP file; unindexed files are limited to 1GB");const e=await J(),n=this.#e.stream.getReader(),t=[],r=new Set;let o=0;const c=new Map,p=new Map,a=new Map;let l,i,m;function h(f){switch(f.type){default:break;case"Header":{m=f.profile;break}case"Schema":{const v=p.get(f.id);if(v&&!(0,Z.isEqual)(v,f))throw new Error(`differing schemas for id ${f.id}`);p.set(f.id,f);break}case"Channel":{const v=a.get(f.id);if(v){if(!(0,Z.isEqual)(v.channel,f))throw new Error(`differing channel infos for id ${f.id}`);break}if(r.has(f.id))break;const I=p.get(f.schemaId);if(f.schemaId!==0&&!I)throw new Error(`Encountered channel with schema id ${f.schemaId} but no prior schema`);try{const B=k({messageEncoding:f.messageEncoding,schema:I});a.set(f.id,{channel:f,parsedChannel:B,schemaName:I?.name}),c.set(f.id,[])}catch(B){r.add(f.id),t.push({severity:"error",message:`Error in topic ${f.topic} (channel ${f.id}): ${B.message}`,error:B})}break}case"Message":{const v=f.channelId,I=a.get(v),B=c.get(v);if(!I||!B){if(r.has(v))break;throw new Error(`message for channel ${v} with no prior channel info`)}++o;const $=(0,y.fromNanoSec)(f.logTime);(!l||(0,y.isLessThan)($,l))&&(l=$),(!i||(0,y.isGreaterThan)($,i))&&(i=$),B.push({topic:I.channel.topic,receiveTime:$,publishTime:(0,y.fromNanoSec)(f.publishTime),message:I.parsedChannel.deserialize(f.data),sizeInBytes:f.data.byteLength,schemaName:I.schemaName??""});break}}}const w=new C.c1({decompressHandlers:e});for(let f;f=await n.read(),!f.done;){w.append(f.value);for(let v;v=w.nextRecord();)h(v)}this.#s=c;const g=[],b=new Map,E=new Map,S=new Map;for(const{channel:f,parsedChannel:v,schemaName:I}of a.values()){g.push({name:f.topic,schemaName:I});const B=c.get(f.id)?.length;B!=null&&b.set(f.topic,{numMessages:B});const $=f.metadata.get("callerid")??String(f.id);let M=S.get(f.topic);M||(M=new Set,S.set(f.topic,M)),M.add($);for(const[be,ve]of v.datatypes)E.set(be,ve)}if(this.#t=l??{sec:0,nsec:0},this.#n=i??{sec:0,nsec:0},(0,y.toSec)((0,y.subtract)(this.#n,this.#t))>me){const f=(0,y.toRFC3339String)(this.#t),v=(0,y.toRFC3339String)(this.#n);t.push({message:"This file has an abnormally long duration.",tip:`The start ${f} and end ${v} are greater than a year.`,severity:"warn"})}return o===0?t.push({message:"This file contains no messages.",severity:"warn"}):t.push({message:"This file is unindexed. Unindexed files may have degraded performance.",tip:"See the MCAP spec: https://mcap.dev/specification/index.html#summary-section",severity:"warn"}),{start:this.#t,end:this.#n,topics:g,datatypes:E,profile:m,problems:t,publishersByTopic:S,topicStats:b}}async*messageIterator(e){if(!this.#s)throw new Error("initialization not completed");const n=e.topics,t=e.start??this.#t,r=e.end??this.#n;if(n.size===0||!t||!r)return;const o=new Map(n),c=[];for(const[p,a]of this.#s)for(const l of a)(0,y.isTimeInRangeInclusive)(l.receiveTime,t,r)&&o.has(l.topic)&&c.push({type:"message-event",connectionId:p,msgEvent:l});c.sort((p,a)=>(0,y.compare)(p.msgEvent.receiveTime,a.msgEvent.receiveTime)),yield*c}async getBackfillMessages(e){if(!this.#s)throw new Error("initialization not completed");const n=e.topics,t=new Map;for(const[r,o]of this.#s)for(const c of o)(0,y.compare)(c.receiveTime,e.time)<=0&&n.has(c.topic)&&t.set(c.topic,c);return[...t.values()]}}var le=u(20865),ue=u(88499);class he{#e;constructor(e){const n=new le.Z(e);this.#e=new ue.Z({fileReader:n,cacheSizeInBytes:1024*1024*200})}async open(){await this.#e.open()}async size(){return BigInt(this.#e.size())}async read(e,n){if(e+n>Number.MAX_SAFE_INTEGER)throw new Error(`Read too large: offset ${e}, size ${n}`);return await this.#e.read(Number(e),Number(n))}}var ge="../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIterableSource.ts";const ye=R.ZP.getLogger(ge);async function G(s){const e=await J();try{const n=await C.RS.Initialize({readable:s,decompressHandlers:e});return n.chunkIndexes.length===0||n.channelsById.size===0?void 0:n}catch(n){ye.error(n);return}}class W{#e;#s;constructor(e){this.#e=e}async initialize(){const e=this.#e;switch(e.type){case"file":{await e.file.slice(0,1).arrayBuffer();const n=new de(e.file),t=await G(n);t?this.#s=new V(t):this.#s=new H({size:e.file.size,stream:e.file.stream()});break}case"url":{const n=new he(e.url);await n.open();const t=await G(n);if(t)this.#s=new V(t);else{const r=await fetch(e.url);if(!r.body)throw new Error(`Unable to stream remote file. <${e.url}>`);const o=r.headers.get("content-length");if(o==null)throw new Error(`Remote file is missing Content-Length header. <${e.url}>`);this.#s=new H({size:parseInt(o),stream:r.body})}break}}return await this.#s.initialize()}messageIterator(e){if(!this.#s)throw new Error("Invariant: uninitialized");return this.#s.messageIterator(e)}async getBackfillMessages(e){if(!this.#s)throw new Error("Invariant: uninitialized");return await this.#s.getBackfillMessages(e)}}function we(s){if(s.file){const e=new W({type:"file",file:s.file}),n=new A.a(e);return x.sj(n)}else if(s.url){const e=new W({type:"url",url:s.url}),n=new A.a(e);return x.sj(n)}throw new Error("file or url required")}x.Jj(we)}}]);

//# sourceMappingURL=7794.d81ea545324c076baa88.js.map