(()=>{var ce={93986:(i,d,a)=>{"use strict";var _=a(80144),e=a.n(_);function l(t,n){const r=[];let o=0;for(const s of t){const u=n(s,o++);u&&r.push(u)}return r}const T=[e().factory.createModifier(e().SyntaxKind.ExportKeyword),e().factory.createModifier(e().SyntaxKind.DeclareKeyword)],m=(t,n)=>e().factory.createPropertySignature(void 0,t,void 0,n),x=t=>e().factory.createInterfaceDeclaration(T,t,void 0,void 0,[m("sec",e().factory.createKeywordTypeNode(e().SyntaxKind.NumberKeyword)),m("nsec",e().factory.createKeywordTypeNode(e().SyntaxKind.NumberKeyword))]),I=e().factory.createInterfaceDeclaration(T,"json",void 0,void 0,[]),O=t=>t.replace(/\//g,"__"),R=new Map([["uint8",e().SyntaxKind.NumberKeyword],["int8",e().SyntaxKind.NumberKeyword],["uint16",e().SyntaxKind.NumberKeyword],["int16",e().SyntaxKind.NumberKeyword],["uint32",e().SyntaxKind.NumberKeyword],["int32",e().SyntaxKind.NumberKeyword],["float32",e().SyntaxKind.NumberKeyword],["float64",e().SyntaxKind.NumberKeyword],["int64",e().SyntaxKind.NumberKeyword],["uint64",e().SyntaxKind.NumberKeyword],["string",e().SyntaxKind.StringKeyword],["bool",e().SyntaxKind.BooleanKeyword]]),P=new Map([["uint8","Uint8Array"],["int8","Int8Array"]]),B=x("Time"),V=x("Duration"),Pe=new Map([["time",B],["duration",V]]),pe=t=>{const n={};for(const[r,o]of t){if(r.includes(".")||n[r])continue;const s=l(o.definitions,({name:u,type:p,isArray:y,isConstant:c})=>{let b;const D=P.get(p),L=R.get(p),M=Pe.get(p);if(c!==!0)return y===!0&&D!=null?b=e().factory.createTypeReferenceNode(D):L!=null?b=e().factory.createKeywordTypeNode(L):M?b=e().factory.createTypeReferenceNode(M.name):b=e().factory.createTypeReferenceNode(O(p)),y===!0&&D==null&&(b=e().factory.createArrayTypeNode(b)),m(u,b)});n[r]=e().factory.createInterfaceDeclaration([e().factory.createModifier(e().SyntaxKind.ExportKeyword)],O(r),void 0,void 0,s)}return n},Ie=({topics:t,datatypes:n})=>{let r=e().factory.createInterfaceDeclaration(T,"TopicsToMessageDefinition",void 0,void 0,[]);const o=e().factory.createInterfaceDeclaration(T,"Input",[e().factory.createTypeParameterDeclaration([],"T",e().factory.createTypeOperatorNode(e().SyntaxKind.KeyOfKeyword,e().factory.createTypeReferenceNode(r.name)))],void 0,[m("topic",e().factory.createTypeReferenceNode("T")),m("receiveTime",e().factory.createTypeReferenceNode("Time")),m("message",e().factory.createTypeReferenceNode("TopicsToMessageDefinition[T]"))]),s="Messages";let u=pe(n);t.forEach(({name:D,schemaName:L})=>{L!=null&&(u[L]||(u={...u,...pe(new Map(Object.entries({[L]:{definitions:[]}})))}),r=e().factory.updateInterfaceDeclaration(r,T,r.name,void 0,void 0,[...r.members,m(e().factory.createStringLiteral(D),e().factory.createTypeReferenceNode(`${s}.${O(L)}`))]))});const p=e().factory.createModuleDeclaration(T,e().factory.createIdentifier(s),e().factory.createModuleBlock(Object.values(u).map(D=>D)),e().NodeFlags.Namespace),y=e().createSourceFile("","",e().ScriptTarget.Latest,!1,e().ScriptKind.TS),c=e().createPrinter();return`
    ${c.printNode(e().EmitHint.Unspecified,I,y)}
    ${c.printNode(e().EmitHint.Unspecified,r,y)}
    ${c.printNode(e().EmitHint.Unspecified,V,y)}
    ${c.printNode(e().EmitHint.Unspecified,B,y)}

    /**
     * This type contains every message declaration in your bag, so that you can
     * refer to the type "std_msgs/RGBA" as "std_msgs__RGBA" wherever you like.
     */
    ${c.printNode(e().EmitHint.Unspecified,p,y)}

    /**
     * To correctly type your inputs, you use this type to refer to specific
     * input topics, e.g. 'Input<"/your_input_topic">'. If you have
     * multiple input topics, use a union type, e.g.
     * 'Input<"/your_input_topic_1"> |
     * Input<"/your_input_topic_2">'.
     *
     * These types are dynamically generated from the bag(s) currently in your
     * Foxglove Studio session, so if a datatype changes, your User Script
     * may not compile on the newly formatted bag.
     */
    ${c.printNode(e().EmitHint.Unspecified,o,y)}
  `},E={Hint:1,Info:2,Warning:4,Error:8},h={Typescript:"Typescript",DatatypeExtraction:"DatatypeExtraction",InputTopicsChecker:"InputTopicsChecker",OutputTopicChecker:"OutputTopicChecker",Runtime:"Runtime"},w={RUNTIME:1,DatatypeExtraction:{NO_DEFAULT_EXPORT:1,NON_FUNC_DEFAULT_EXPORT:2,NO_TYPE_RETURN:3,BAD_TYPE_RETURN:4,UNKNOWN_ERROR:5,NO_UNIONS:6,NO_FUNCTIONS:7,NO_CLASSES:8,NO_TYPE_LITERALS:9,NO_TUPLES:10,NO_INTERSECTION_TYPES:11,NO_TYPEOF:12,PREFER_ARRAY_LITERALS:13,STRICT_MARKERS_RETURN_TYPE:14,LIMITED_UNIONS:15,NO_NESTED_ANY:16,NO_MAPPED_TYPES:17,INVALID_PROPERTY:18,INVALID_INDEXED_ACCESS:19},InputTopicsChecker:{NO_TOPIC_AVAIL:1,NO_INPUTS_EXPORT:2,EMPTY_INPUTS_EXPORT:3,BAD_INPUTS_TYPE:4},OutputTopicChecker:{NO_OUTPUTS:1,NOT_UNIQUE:2,EXISTING_TOPIC:3}},de={severity:E.Error,message:"No 'default export' function found.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.NO_DEFAULT_EXPORT},fe={severity:E.Error,message:"The 'default export' must be assigned to a function.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.NON_FUNC_DEFAULT_EXPORT},j={severity:E.Error,message:"The 'default export' function must return an object type with at least one property.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.BAD_TYPE_RETURN},Oe={severity:E.Error,message:"The 'default export' function can only return union types of the form: 'YourType | undefined'.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.LIMITED_UNIONS},De={severity:E.Error,message:"Unions are not allowed in return type.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.NO_UNIONS},le={severity:E.Error,message:"Functions are not allowed as or in the return type.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.NO_FUNCTIONS},Re={severity:E.Error,message:"Type literals are not allowed as or in the return type.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.NO_TYPE_LITERALS},ye={severity:E.Error,message:"Type intersections are not allowed as or in the return type.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.NO_INTERSECTION_TYPES},Ce={severity:E.Error,message:"Please use array literal syntax (e.g. 'number[]') instead of the 'Array<number>'.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.PREFER_ARRAY_LITERALS},Q={severity:E.Error,message:"Classes are not allowed as or in the return type.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.NO_CLASSES},ve={severity:E.Error,message:"'typeof' cannot be used as or in the return type",source:h.DatatypeExtraction,code:w.DatatypeExtraction.NO_TYPEOF},Ke={severity:E.Error,message:"Tuples are not allowed as types.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.NO_TUPLES},Me={severity:E.Error,message:"Cannot nest 'any' in the return type.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.NO_NESTED_ANY},Ae={severity:E.Error,message:"MappedTypes such as Record<Keys,Type> are not supported.",source:h.DatatypeExtraction,code:w.DatatypeExtraction.NO_MAPPED_TYPES},ge=100;class S extends Error{diagnostic;constructor(n){super(),this.diagnostic=n}}const Le=(t,n)=>e().forEachChild(t,r=>{if(n.includes(r.kind))return r}),X=(t,n)=>{for(const r of t.declarations??[])if(n.includes(r.kind))return r},ke=(t,n,r)=>{const o=q(n);if(!o)return;const s=t.getDeclaredTypeOfSymbol(o);return X(s.symbol??s.aliasSymbol,r)},Ee=(t=[],n)=>{const r={};for(let o=0;o<t.length;o++){const s=t[o];s&&(r[s.name.escapedText.toString()]={current:s,parent:n[o]??{parent:void 0,current:s.default}})}return r},Fe=(t=[],n)=>{const r={};return t.forEach((o,s)=>{const u=o.getText(),p=n[u]??n[s],y=o;r[s]={current:y,parent:p}}),r},Te=t=>t.getSourceFile().fileName.endsWith("ros/index.d.ts");function q(t){return t?.symbol}const Ue=(t,n)=>{const r=q(t);if(!r)return;const o=n.getExportsOfModule(r).find(y=>y.escapedName==="default");if(!o)throw new S(de);const s=X(o,[e().SyntaxKind.FunctionDeclaration]);if(s)return s;const u=X(o,[e().SyntaxKind.ExportAssignment]);if(!u)throw new S(de);const p=Le(u,[e().SyntaxKind.FunctionDeclaration,e().SyntaxKind.FunctionExpression,e().SyntaxKind.ArrowFunction,e().SyntaxKind.Identifier]);if(!p)throw new S(fe);return p},Be=(t,n)=>{const o=t.getTypeAtLocation(n).getCallSignatures(),s=o[0];if(o.length!==1||!s)throw new S(fe);const p=t.getReturnTypeOfSignature(s).getNonNullableType();if(p.isIntersection())throw new S(ye);if(p.isClass())throw new S(Q);if(p.isUnion())throw new S(Oe);const y=p.getSymbol();if(!y)throw new S(j);if(!y.declarations||y.declarations.length===0)throw new S(j);let c;if(y.declarations.length===1?c=y.declarations[0]:c=y.declarations.filter(b=>b.kind===e().SyntaxKind.InterfaceDeclaration)[0],!c)throw new S(j);if(e().isTypeLiteralNode(c))return c;if(e().isInterfaceDeclaration(c))return c;throw e().isMappedTypeNode(c)?new S(Ae):e().isClassDeclaration(c)?new S(Q):e().isFunctionLike(c)?new S(le):new S(j)},me=(t,n,r,o,s,u=1,p={})=>{if(u>ge)throw new Error("Max AST traversal depth exceeded.");const y=e().isInterfaceDeclaration(n)?n.name.text:void 0,c=y!=null?o[y]:void 0;if(Te(n)&&c!=null)return{outputDatatype:c,datatypes:s};const b=n.getSourceFile().fileName;if(b==="/studio_script/generatedTypes.ts"&&e().isPropertySignature(n.parent)&&e().isStringLiteral(n.parent.name))return{outputDatatype:n.parent.name.text,datatypes:s};const D=/^\/studio_script\/node_modules\/@foxglove\/schemas\/(\w+)\.ts$/,M=b.match(D)?.[1];if(M)return{outputDatatype:`foxglove.${M}`,datatypes:s};let J=new Map;const U=(f,N,C=!1,A=!1,k={},W=1)=>{if(W>ge)throw new Error("Max AST traversal depth exceeded.");switch(N.kind){case e().SyntaxKind.InterfaceDeclaration:case e().SyntaxKind.TypeLiteral:{const v=N,K=q(N)?.name,F=K!=null?o[K]:void 0,Y=Te(v)&&F!=null?F:`${r}/${f}`,$=e().isInterfaceDeclaration(N)?Ee(N.typeParameters,k):k,{datatypes:Ne}=me(t,v,Y,o,s,u+1,$),oe=Ne.get(Y)?.definitions??[];if(oe.length===2){const se=oe.find(ie=>ie.name==="sec"),ae=oe.find(ie=>ie.name==="nsec");if(se&&ae&&se.isComplex!==!0&&ae.isComplex!==!0&&se.isArray!==!0&&ae.isArray!==!0)return{name:f,type:"time",isArray:!1,isComplex:!1,arrayLength:void 0}}return J=new Map([...J,...Ne]),{name:f,type:Y,isArray:C,isComplex:!0,arrayLength:void 0}}case e().SyntaxKind.ArrayType:return U(f,N.elementType,!0,!0,k,W+1);case e().SyntaxKind.BigIntKeyword:return{name:f,type:"int64",isArray:C,isComplex:A,arrayLength:void 0};case e().SyntaxKind.NumberKeyword:return{name:f,type:"float64",isArray:C,isComplex:A,arrayLength:void 0};case e().SyntaxKind.StringKeyword:return{name:f,type:"string",isArray:C,isComplex:A,arrayLength:void 0};case e().SyntaxKind.BooleanKeyword:return{name:f,type:"bool",isArray:C,isComplex:A,arrayLength:void 0};case e().SyntaxKind.TypeAliasDeclaration:{const v=N,K=Ee(v.typeParameters,k);return U(f,v.type,C,A,K,W+1)}case e().SyntaxKind.TypeReference:{const v=N,K=t.getSymbolAtLocation(v.typeName);if(K?.escapedName==="Array")throw new S(Ce);if(!K)throw new Error("Could not find symbol");const F=X(K,[e().SyntaxKind.TypeParameter]);if(F){if(k[F.name.escapedText.toString()]){let $=k[F.name.escapedText.toString()];for(;$?.parent;)$=$.parent;return U(f,$.current,C,A,k,W+1)}throw new Error(`Could not find type ${F.getText()} in type map.`)}const Y=X(K,[e().SyntaxKind.TypeAliasDeclaration,e().SyntaxKind.InterfaceDeclaration,e().SyntaxKind.ImportSpecifier,e().SyntaxKind.ClassDeclaration,e().SyntaxKind.EnumDeclaration]);if(!Y)throw new Error("Could not find next node");return U(f,Y,C,A,Fe(v.typeArguments,k),W+1)}case e().SyntaxKind.TypeQuery:throw new S(ve);case e().SyntaxKind.ImportSpecifier:{const v=ke(t,N,[e().SyntaxKind.TypeLiteral,e().SyntaxKind.InterfaceDeclaration,e().SyntaxKind.TypeAliasDeclaration]);if(!v)throw new Error("Failed to find import declaration");return U(f,v,C,A,k,W+1)}case e().SyntaxKind.IntersectionType:throw new S(ye);case e().SyntaxKind.TupleType:throw new S(Ke);case e().SyntaxKind.StringLiteral:case e().SyntaxKind.NumericLiteral:case e().SyntaxKind.LiteralType:throw new S(Re);case e().SyntaxKind.ClassDeclaration:throw new S(Q);case e().SyntaxKind.EnumDeclaration:return{name:f,type:"uint32",isArray:C,isComplex:A,arrayLength:void 0};case e().SyntaxKind.UnionType:throw new S(De);case e().SyntaxKind.FunctionType:throw new S(le);case e().SyntaxKind.AnyKeyword:throw new S(Me);default:{const K=t.getTypeAtLocation(N).symbol;if(K==null)throw new S({severity:E.Error,message:`Unsupported type for member '${f}'.`,source:h.DatatypeExtraction,code:w.DatatypeExtraction.BAD_TYPE_RETURN});const F=K.declarations?.[0];if(K.declarations?.length!==1||!F)throw new S(j);return U(f,F,!1,void 0,k,W+1)}}},{members:re=[]}=n,ne=re.map(f=>{if(!f.name)throw new S({severity:E.Error,message:`Encountered type member with no name in ${y??r}`,source:h.DatatypeExtraction,code:w.DatatypeExtraction.INVALID_PROPERTY});if(!e().isPropertySignature(f))throw new S({severity:E.Error,message:`Unexpected type member (kind ${f.kind}) in ${y??r}`,source:h.DatatypeExtraction,code:w.DatatypeExtraction.INVALID_PROPERTY});if(!f.type)throw new S({severity:E.Error,message:`Member ${f.name.getText()} has no type in ${y??r}`,source:h.DatatypeExtraction,code:w.DatatypeExtraction.INVALID_PROPERTY});return U(f.name.getText(),f.type,!1,!1,p,u+1)});return{outputDatatype:r,datatypes:new Map([...J,...new Map([[r,{definitions:ne}]])])}};var We=a(64942);const Ye=t=>{switch(t){case e().DiagnosticCategory.Error:return E.Error;case e().DiagnosticCategory.Warning:return E.Warning;case e().DiagnosticCategory.Message:return E.Info;case e().DiagnosticCategory.Suggestion:return E.Hint;default:throw new Error("Diagnostic category not recognized")}},$e=t=>{if(!t.file||t.start==null||t.length==null)throw new Error("Invariant: diagnostic is not initialized");const{line:n,character:r}=t.file.getLineAndCharacterOfPosition(t.start),{line:o,character:s}=t.file.getLineAndCharacterOfPosition(t.start+t.length);return{message:_e(t.messageText,`
`),severity:Ye(t.category),source:"Typescript",startLineNumber:n,startColumn:r,endLineNumber:o,endColumn:s,code:t.code}};function _e(t,n,r=0){if(typeof t=="string")return t;if(t==null)return"";let o="";if(r>0){o+=n;for(let s=0;s<r;s++)o+="  "}if(o+=t.messageText,t.next)for(const s of t.next)o+=_e(s,n,r+1);return o}const he={strict:!0,target:e().ScriptTarget.ES2022,module:e().ModuleKind.CommonJS};var je=a(11701);const Xe=`type MessageTypeByTopic = {
  // placeholder
};
type MessageTypeBySchemaName = {
  // placeholder
};

export type { MessageTypeByTopic, MessageTypeBySchemaName };
`,we=t=>t.diagnostics.some(({severity:n})=>n===E.Error),Ze=t=>{const{sourceFile:n,typeChecker:r}=t;if(!n||!r){const c={severity:E.Error,message:"Either the 'sourceFile' or 'typeChecker' is absent. There is a problem with the `compile` step.",source:h.InputTopicsChecker,code:w.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,c]}}const o=r.getSymbolAtLocation(n);if(!o){const c={severity:E.Error,message:"Must export an input topics array. E.g. 'export const inputs = ['/some_topics']'",source:h.InputTopicsChecker,code:w.InputTopicsChecker.NO_INPUTS_EXPORT};return{...t,diagnostics:[...t.diagnostics,c]}}const s=r.getExportsOfModule(o).find(c=>c.escapedName==="inputs");if(!s){const c={severity:E.Error,message:"Must export a non-empty inputs array.",source:h.InputTopicsChecker,code:w.InputTopicsChecker.EMPTY_INPUTS_EXPORT};return{...t,diagnostics:[...t.diagnostics,c]}}const u=s.declarations?.[0];if(!u||!e().isVariableDeclaration(u)){const c={severity:E.Error,message:"inputs export must be an array variable.",source:h.InputTopicsChecker,code:w.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,c]}}if(!u.initializer||!e().isArrayLiteralExpression(u.initializer)){const c={severity:E.Error,message:"inputs export must be an array variable.",source:h.InputTopicsChecker,code:w.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,c]}}const p=u.initializer.elements;if(p.some(({kind:c})=>c!==e().SyntaxKind.StringLiteral)){const c={severity:E.Error,message:"The exported 'inputs' variable must be an array of string literals. E.g. 'export const inputs = ['/some_topics']'",source:h.InputTopicsChecker,code:w.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,c]}}const y=l(p,c=>{if(e().isStringLiteral(c))return c.text});if(y.length===0){const c={severity:E.Error,message:'Must include non-empty inputs array, e.g. export const inputs = ["/some_input_topic"];',source:h.InputTopicsChecker,code:w.InputTopicsChecker.EMPTY_INPUTS_EXPORT};return{...t,diagnostics:[...t.diagnostics,c]}}return{...t,inputTopics:y}},He=t=>{const n=/^\s*export\s+const\s+output\s*=\s*("([^"]+)"|'([^']+)')/gm.exec(t.sourceCode),r=n?.[2]??n?.[3];if(r==null){const o={severity:E.Error,message:`Must include an output, e.g. export const output = "${je.wd}your_output_topic";`,source:h.OutputTopicChecker,code:w.OutputTopicChecker.NO_OUTPUTS};return{...t,diagnostics:[...t.diagnostics,o]}}return{...t,outputTopic:r}},Ve=(t,n)=>{const{inputTopics:r}=t,o=n.map(({name:u})=>u),s=[];for(const u of r)o.includes(u)||s.push({severity:E.Error,message:`Input "${u}" is not yet available`,source:h.InputTopicsChecker,code:w.InputTopicsChecker.NO_TOPIC_AVAIL});return{...t,diagnostics:[...t.diagnostics,...s]}},Ge=t=>{const{sourceCode:n,rosLib:r,typesLib:o}=t,s=he,u="/studio_script/index.ts",p=(0,We.L)(),y=new Map,c=new Map;c.set(u,n),c.set(p.rosLib.filePath,r),c.set("/studio_script/generatedTypes.ts",o||Xe),p.utilityFiles.forEach(f=>c.set(f.filePath,f.sourceCode)),p.declarations.forEach(f=>c.set(f.filePath,f.sourceCode));let b="",D=!1;const L={getDefaultLibFileName:()=>p.defaultLibFileName,getCurrentDirectory:()=>"",getCanonicalFileName:f=>f,useCaseSensitiveFileNames:()=>!1,readFile:()=>{},fileExists:f=>{for(const[N]of c.entries())if(f===N||f.endsWith(N))return!0;return!1},writeFile:(f,N)=>{D=!0,f==="/studio_script/index.js"?b=N:y.set(f,N)},getNewLine:()=>`
`,getSourceFile:f=>{let N="";for(const[C,A]of c.entries())if(f===C||f.endsWith(C)){N=A;break}return e().createSourceFile(f,N,he.target,!0)}},M=e().createProgram([u],s,L);if(M.emit(),!D){const f={severity:E.Error,message:"Program code was not emitted.",source:h.InputTopicsChecker,code:w.InputTopicsChecker.BAD_INPUTS_TYPE};return{...t,diagnostics:[...t.diagnostics,f]}}const U=[...M.getSemanticDiagnostics(),...M.getSyntacticDiagnostics()].map($e),re=M.getSourceFile(u),ne=M.getTypeChecker();return{...t,sourceFile:re,typeChecker:ne,transpiledCode:b,projectCode:y,diagnostics:[...t.diagnostics,...U]}},ze=t=>{if(we(t))return t;const{sourceFile:n}=t;if(!n)throw new Error("'sourceFile' is absent'. There is a problem with the `compile` step.");const r=n.forEachChild(s=>{if(e().isTypeAliasDeclaration(s)&&e().isTypeLiteralNode(s.type)&&s.name.text==="GlobalVariables")return s.type.members;if(e().isInterfaceDeclaration(s)&&s.name.text==="GlobalVariables")return s.members}),o=l(r??[],s=>{if(s.name&&(e().isIdentifier(s.name)||e().isStringLiteral(s.name)))return s.name.text});return{...t,globalVariables:o}},Je=t=>{if(we(t))return t;const{sourceFile:n,typeChecker:r,name:o,datatypes:s}=t;if(!n||!r)throw new Error("Either the 'sourceFile' or 'typeChecker' is absent'. There is a problem with the `compile` step.");const u={};for(const p of s.keys())u[O(p)]=p;try{const p=Ue(n,r);if(!p)throw new Error("Your node must default export a function");const y=Be(r,p),{outputDatatype:c,datatypes:b}=me(r,y,o,u,s);return{...t,datatypes:b,outputDatatype:c}}catch(p){return p instanceof S?{...t,diagnostics:[...t.diagnostics,p.diagnostic]}:{...t,diagnostics:[...t.diagnostics,{message:p.message,severity:E.Error,source:h.DatatypeExtraction,code:w.DatatypeExtraction.UNKNOWN_ERROR}]}}},Qe=(...t)=>(n,r)=>{let o=n;for(const s of t)o=s(o,r);return o},qe=t=>{const{name:n,sourceCode:r,topics:o,rosLib:s,typesLib:u,datatypes:p}=t;return{...Qe(He,Ge,Ze,Ve,Je,ze)({name:n,sourceCode:r,rosLib:s,typesLib:u,transpiledCode:"",projectCode:void 0,inputTopics:[],outputTopic:"",outputDatatype:"",diagnostics:[],globalVariables:[],datatypes:p,sourceFile:void 0,typeChecker:void 0},o),sourceFile:void 0,typeChecker:void 0}};var ee;const Z="$$RESPONSE",te="$$ERROR";function dt(){const t={onmessage:void 0,postMessage(r,o){const s=new MessageEvent("message",{data:r});n.onmessage&&n.onmessage(s)},terminate:()=>{}},n={onmessage:void 0,postMessage(r,o){const s=new MessageEvent("message",{data:r});t.onmessage&&t.onmessage(s)},terminate:()=>{}};return{local:t,remote:n}}class Se{static transferables="$$TRANSFERABLES";#e;#n=0;#t={};#r=new Map;constructor(n){if(this.#e=n,this.#e.onmessage)throw new Error("channel.onmessage is already set. Can only use one Rpc instance per channel.");this.#e.onmessage=this.#o}#o=n=>{const{id:r,topic:o,data:s}=n.data;if(o===Z){this.#t[r]?.(n.data),delete this.#t[r];return}new Promise(u=>{const p=this.#r.get(o);if(!p)throw new Error(`no receiver registered for ${o}`);u(p(s))}).then(u=>{if(!u){this.#e.postMessage({topic:Z,id:r});return}const p=u[ee.transferables];delete u[ee.transferables];const y={topic:Z,id:r,data:u};this.#e.postMessage(y,p)}).catch(u=>{const p={topic:Z,id:r,data:{[te]:!0,name:u.name,message:u.message,stack:u.stack}};this.#e.postMessage(p)})};terminate(){for(const[n,r]of Object.entries(this.#t))r({topic:Z,id:n,data:{[te]:!0,name:"Error",message:"Rpc terminated",stack:new Error().stack}})}async send(n,r,o){const s=this.#n++,u={topic:n,id:s,data:r},p=new Promise((y,c)=>{this.#t[s]=b=>{if(b.data?.[te]!=null){const D=new Error(b.data.message);D.name=b.data.name,D.stack=b.data.stack,c(D)}else y(b.data)}});return this.#e.postMessage(u,o),await p}receive(n,r){if(this.#r.has(n))throw new Error(`Receiver already registered for topic: ${n}`);this.#r.set(n,r)}}ee=Se;const et=Se,xe=a.g;function tt(t){xe.foxgloveStudioReportErrorFn?.(t)}function ft(t){xe.foxgloveStudioReportErrorFn=t}class rt extends Error{details;extraInfo;message;constructor(n,r){if(super(),this.details=n,this.extraInfo=r,this.name="AppError",this.message="",n instanceof Error?this.message=n.stack??n.message:typeof n=="string"&&(this.message=n),r!=null)if(r.componentStack!=null)this.message+=`

${r.componentStack}`;else try{const o=JSON.stringify(r);this.message+=`

${o}`}catch{this.message+=`

[ Either cyclic object or object with BigInt(s) ]`}this.message===""&&(this.message="Unknown Error")}}const nt=()=>typeof a.g.postMessage<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,ot=()=>typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope,st=t=>{const n=typeof fetch<"u"&&fetch("data:test").then(()=>!0).catch(()=>!1);return async(...r)=>{if(await n)throw new Error("Content security policy too loose.");return t(...r)}},G=(t,n,r,o)=>{if(nt()){(o==="error"?console.error:o==="warn"?console.warn:console.info)("Web Worker has uninitialized sendNotification function; this means this error message cannot show up in the UI (so we show it here in the console instead).",t,n,r);return}console.error("Notification before error display is mounted",t,n,r)};let H=G;function at(t){if(H!==G)throw new Error("Tried to overwrite existing NotificationHandler");H=t}function lt(){if(H===G)throw new Error("Tried to unset NotificationHandler but it was already the default");H=G}function it(t,n,r,o){r==="app"&&(o==="warn"||o==="error")&&tt(new rt(n,t)),H(t,n,r,o)}it.expectCalledDuringTest=()=>{throw new Error("Should be overriden in setupTestFramework.ts")};function be(t){at((n,r,o,s)=>{r instanceof Error||typeof r=="string"||console.warn("Invalid Error type",r),t.send("sendNotification",{message:n,details:r instanceof Error?r.toString():r,type:o,severity:s})})}function yt(t){be(t),overwriteFetch()}let z=[];if(a.g.onerror=t=>{z.push(t.error.toString())},a.g.onunhandledrejection=t=>{z.push(String(t.reason instanceof Error?t.reason.message:t.reason))},!ot())throw new Error("Not in a SharedWorker.");a.g.onconnect=t=>{const n=t.ports[0];if(!n)throw new Error("NodeTransformWorker connect requires at least 1 message port.");const r=new et(n);z.forEach(async o=>{await r.send("error",o)}),z=[],a.g.onerror=o=>{r.send("error",o.error.toString())},a.g.onunhandledrejection=o=>{r.send("error",String(o.reason instanceof Error?o.reason.message:o.reason))},be(r),r.receive("close",()=>{a.g.close()}),r.receive("transform",st(qe)),r.receive("generateRosLib",Ie),n.start()}},23621:(i,d,a)=>{"use strict";a.d(d,{Y:()=>_,k:()=>e});const _="ros/index.d.ts",e=`
  export declare interface Duration {
    sec: number;
    nsec: number;
  }

  export declare interface Time {
    sec: number;
    nsec: number;
  }

  // Once a data source Messages will be populated with interfaces matching the data source messages.
  export declare namespace Messages {}

  // Once a data source TopicsToMessageDefinition will be populated with topic names to message interfaces.
  export declare interface TopicsToMessageDefinition {}

  /**
   * To correctly type your inputs, you use this type to refer to specific
   * input topics, e.g. 'Input<"/your_input_topic">'. If you have
   * multiple input topics, use a union type, e.g.
   * 'Input<"/your_input_topic_1"> |
   * Input<"/your_input_topic_2">'.
   *
   * These types are dynamically generated from the bag(s) currently in your
   * Foxglove Studio session, so if a datatype changes, your User Script
   * may not compile on the newly formatted bag.
   */
  export declare interface Input<T extends keyof TopicsToMessageDefinition> {
    topic: T;
    receiveTime: Time;
    message: TopicsToMessageDefinition[T];
  }

`},11701:(i,d,a)=>{"use strict";a.d(d,{wd:()=>_});const _="/studio_script/";function e(){const{palette:{mode:T,text:m}}=useTheme();return{dark:{base00:"transparent",base0B:"#ffa657",base09:"#7ee787",base07:"#79c0ff",base08:"#ff7b72",base0D:"#79c0ff",base03:m.secondary},light:{base00:"transparent",base0B:"#953800",base09:"#116329",base07:"#0550ae",base08:"#cf222e",base0D:"#0550ae",base03:m.secondary}}[T]}const l="Tab"},63136:(i,d,a)=>{"use strict";a.d(d,{Z:()=>e});const e={nextTick:(l,...T)=>{queueMicrotask(()=>{l(...T)})},title:"browser",browser:!0,env:{},argv:[]}},89424:()=>{},9445:()=>{},70546:()=>{},15490:()=>{},80136:()=>{},91389:()=>{},9865:()=>{},73860:()=>{},98752:()=>{},95598:(i,d,a)=>{"use strict";a.d(d,{Z:()=>e});function _(l,T){for(var m=-1,x=l==null?0:l.length,I=Array(x);++m<x;)I[m]=T(l[m],m,l);return I}const e=_},79200:(i,d,a)=>{"use strict";a.d(d,{Z:()=>R});var _=a(187),e=a(95598),l=a(97885),T=a(22758),m=1/0,x=_.Z?_.Z.prototype:void 0,I=x?x.toString:void 0;function O(P){if(typeof P=="string")return P;if((0,l.Z)(P))return(0,e.Z)(P,O)+"";if((0,T.Z)(P))return I?I.call(P):"";var B=P+"";return B=="0"&&1/P==-m?"-0":B}const R=O},95965:(i,d,a)=>{"use strict";a.d(d,{Z:()=>x});var _=a(78804),e=a(63282),l=a(66401),T=a(93122);function m(I,O,R){if(!(0,T.Z)(R))return!1;var P=typeof O;return(P=="number"?(0,e.Z)(R)&&(0,l.Z)(O,R.length):P=="string"&&O in R)?(0,_.Z)(R[O],I):!1}const x=m},22758:(i,d,a)=>{"use strict";a.d(d,{Z:()=>m});var _=a(99001),e=a(43391),l="[object Symbol]";function T(x){return typeof x=="symbol"||(0,e.Z)(x)&&(0,_.Z)(x)==l}const m=T},77068:(i,d,a)=>{"use strict";a.d(d,{Z:()=>T});var _=a(43703),e="Expected a function";function l(m,x){if(typeof m!="function"||x!=null&&typeof x!="function")throw new TypeError(e);var I=function(){var O=arguments,R=x?x.apply(this,O):O[0],P=I.cache;if(P.has(R))return P.get(R);var B=m.apply(this,O);return I.cache=P.set(R,B)||P,B};return I.cache=new(l.Cache||_.Z),I}l.Cache=_.Z;const T=l},25186:(i,d,a)=>{"use strict";a.d(d,{Z:()=>l});var _=a(79200);function e(T){return T==null?"":(0,_.Z)(T)}const l=e}},ue={};function g(i){var d=ue[i];if(d!==void 0)return d.exports;var a=ue[i]={exports:{}};return ce[i](a,a.exports,g),a.exports}g.m=ce,g.x=()=>{var i=g.O(void 0,[1084,1401,7472,8239,144,9308,1847,4942],()=>g(93986));return i=g.O(i),i},(()=>{var i=[];g.O=(d,a,_,e)=>{if(a){e=e||0;for(var l=i.length;l>0&&i[l-1][2]>e;l--)i[l]=i[l-1];i[l]=[a,_,e];return}for(var T=1/0,l=0;l<i.length;l++){for(var[a,_,e]=i[l],m=!0,x=0;x<a.length;x++)(e&!1||T>=e)&&Object.keys(g.O).every(V=>g.O[V](a[x]))?a.splice(x--,1):(m=!1,e<T&&(T=e));if(m){i.splice(l--,1);var I=_();I!==void 0&&(d=I)}}return d}})(),g.n=i=>{var d=i&&i.__esModule?()=>i.default:()=>i;return g.d(d,{a:d}),d},g.d=(i,d)=>{for(var a in d)g.o(d,a)&&!g.o(i,a)&&Object.defineProperty(i,a,{enumerable:!0,get:d[a]})},g.f={},g.e=i=>Promise.all(Object.keys(g.f).reduce((d,a)=>(g.f[a](i,d),d),[])),g.u=i=>""+i+"."+{144:"225c949245a52a3277be",1084:"bb60996131e2a2cf072e",1401:"ac7097386ab29ae62948",1847:"8a82db6e66ac600d4515",4942:"38e599c9d5a5f2017b8f",7472:"273f69571dee607e9608",8239:"281f8cd2867dc5cde927",9308:"ad8e52b057e0345f177d"}[i]+".js",g.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),g.o=(i,d)=>Object.prototype.hasOwnProperty.call(i,d),g.r=i=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})},(()=>{var i;g.g.importScripts&&(i=g.g.location+"");var d=g.g.document;if(!i&&d&&(d.currentScript&&(i=d.currentScript.src),!i)){var a=d.getElementsByTagName("script");if(a.length)for(var _=a.length-1;_>-1&&!i;)i=a[_--].src}if(!i)throw new Error("Automatic publicPath is not supported in this browser");i=i.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),g.p=i})(),(()=>{var i={5617:1},d=e=>{var[l,T,m]=e;for(var x in T)g.o(T,x)&&(g.m[x]=T[x]);for(m&&m(g);l.length;)i[l.pop()]=1;_(e)};g.f.i=(e,l)=>{i[e]||importScripts(g.p+g.u(e))};var a=self.webpackChunk=self.webpackChunk||[],_=a.push.bind(a);a.push=d})(),(()=>{var i=g.x;g.x=()=>Promise.all([1084,1401,7472,8239,144,9308,1847,4942].map(g.e,g)).then(i)})();var ct=g.x()})();

//# sourceMappingURL=5617.bb136e7e09efc11c94a4.js.map